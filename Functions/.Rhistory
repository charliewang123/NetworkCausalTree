minpopfrac = 1,
depth = 2,
fracpredictors = 1,
minsize= 15,
n_trees = 1)
rule.sel <- SNCT$FILTER
rule.main <- SNCT_main$FILTER
rule.spil <- SNCT_spil$FILTER
irule.sel
rule.sel
SNCT
i = 10
# Tau1000
tau1000 <- rep(0, n)
tau1000[x1==0 & x2==0] <- i
tau1000[x1==0 & x2==1] <- -i
# Tau 0100
eta0100 <- rep(0, n)
eta0100[x1==1 & x3==0] <- i
eta0100[x1==1 & x3==1] <- -i
## Generate Treatment Effects
y00 <- rnorm(n)
y10 <- y00 + tau1000
y11 <- y01 <- y00 + eta0100
## Generate Outcome
y <- y00*(1-w)*(1-g) + y10*w*(1-g) + y01*(1-w)*g + y11*w*g
## Run the  whole function
## Composite Tree
SNCT <- NetworkCausalTrees(effweights = c(0.5,0,0,0.5), method = "composite", # singular
output = "estimation", # detection, estimation
A = adiac_matrix,
p = rep(probT,n), Ne = NeighNum,
W = w, Y = y, X = X, M = M, G = g,
mdisc = 8, mest = 7,
minpopfrac = 1,
depth = 2,
fracpredictors = 1,
minsize= 15,
n_trees = 1)
## Tree for Main Treatment Effect
SNCT_main <- NetworkCausalTrees(effweights = c(1,0,0,0), method = "singular",
output = "estimation", # detection, estimation
A = adiac_matrix,
p = rep(probT,n), Ne = NeighNum,
W = w, Y = y, X = X, M = M, G = g,
mdisc = 8, mest = 7,
minpopfrac = 1,
depth = 2,
fracpredictors = 1,
minsize= 15,
n_trees = 1)
## Tree for Spillover Effect
SNCT_spil <- NetworkCausalTrees(effweights = c(0,0,0,1), method = "singular",
output = "estimation", # detection, estimation
A = adiac_matrix,
p = rep(probT,n), Ne = NeighNum,
W = w, Y = y, X = X, M = M, G = g,
mdisc = 8, mest = 7,
minpopfrac = 1,
depth = 2,
fracpredictors = 1,
minsize= 15,
n_trees = 1)
rule.sel <- SNCT$FILTER
rule.main <- SNCT_main$FILTER
rule.spil <- SNCT_spil$FILTER
i
rule.sel
plot(density(y))
i
i
# Tau1000
tau1000 <- rep(0, n)
tau1000[x1==0 & x2==0] <- i
tau1000[x1==0 & x2==1] <- -i
# Tau 0100
eta0100 <- rep(0, n)
eta0100[x1==1 & x3==0] <- i
eta0100[x1==1 & x3==1] <- -i
## Generate Treatment Effects
y00 <- rnorm(n)
y11 <- rnorm(n)
y10 <- y00 + tau1000
y01 <- y00 + eta0100
## Generate Outcome
y <- y00*(1-w)*(1-g) + y10*w*(1-g) + y01*(1-w)*g + y11*w*g
## Run the  whole function
## Composite Tree
SNCT <- NetworkCausalTrees(effweights = c(0.5,0,0,0.5), method = "composite", # singular
output = "estimation", # detection, estimation
A = adiac_matrix,
p = rep(probT,n), Ne = NeighNum,
W = w, Y = y, X = X, M = M, G = g,
mdisc = 8, mest = 7,
minpopfrac = 1,
depth = 2,
fracpredictors = 1,
minsize= 15,
n_trees = 1)
## Tree for Main Treatment Effect
SNCT_main <- NetworkCausalTrees(effweights = c(1,0,0,0), method = "singular",
output = "estimation", # detection, estimation
A = adiac_matrix,
p = rep(probT,n), Ne = NeighNum,
W = w, Y = y, X = X, M = M, G = g,
mdisc = 8, mest = 7,
minpopfrac = 1,
depth = 2,
fracpredictors = 1,
minsize= 15,
n_trees = 1)
## Tree for Spillover Effect
SNCT_spil <- NetworkCausalTrees(effweights = c(0,0,0,1), method = "singular",
output = "estimation", # detection, estimation
A = adiac_matrix,
p = rep(probT,n), Ne = NeighNum,
W = w, Y = y, X = X, M = M, G = g,
mdisc = 8, mest = 7,
minpopfrac = 1,
depth = 2,
fracpredictors = 1,
minsize= 15,
n_trees = 1)
rule.sel <- SNCT$FILTER
rule.main <- SNCT_main$FILTER
rule.spil <- SNCT_spil$FILTER
rule.sel
plot(density(y))
yoo
y00
y01
y00
y11
rule.main
rule.spil
rule.sel
SNCT
y[x==1]
y[x1==1]
plot(density(y[x1==1]))
plot(density(y[x3==1]))
plot(density(y[x3==0]))
plot(density(y[x1==0]))
plot(density(y[x2==0]))
plot(density(y[x2==1]))
# Tau1000
tau1000 <- rep(0, n)
tau1000[x1==0 & x2==0] <- i
tau1000[x1==0 & x2==1] <- 2*i
# Tau 0100
eta0100 <- rep(0, n)
eta0100[x1==1 & x3==0] <- -i
eta0100[x1==1 & x3==1] <- -2*i
## Generate Treatment Effects
y00 <- rnorm(n)
y11 <- rnorm(n)
y10 <- y00 + tau1000
y01 <- y00 + eta0100
## Generate Outcome
y <- y00*(1-w)*(1-g) + y10*w*(1-g) + y01*(1-w)*g + y11*w*g
## Run the  whole function
## Composite Tree
SNCT <- NetworkCausalTrees(effweights = c(0.5,0,0,0.5), method = "composite", # singular
output = "estimation", # detection, estimation
A = adiac_matrix,
p = rep(probT,n), Ne = NeighNum,
W = w, Y = y, X = X, M = M, G = g,
mdisc = 8, mest = 7,
minpopfrac = 1,
depth = 2,
fracpredictors = 1,
minsize= 15,
n_trees = 1)
SNCT
i
i = 4
# Tau1000
tau1000 <- rep(0, n)
tau1000[x1==0 & x2==0] <- i
tau1000[x1==0 & x2==1] <- 2*i
# Tau 0100
eta0100 <- rep(0, n)
eta0100[x1==1 & x3==0] <- -i
eta0100[x1==1 & x3==1] <- -2*i
## Generate Treatment Effects
y00 <- rnorm(n)
y11 <- rnorm(n)
y10 <- y00 + tau1000
y01 <- y00 + eta0100
## Generate Outcome
y <- y00*(1-w)*(1-g) + y10*w*(1-g) + y01*(1-w)*g + y11*w*g
## Run the  whole function
## Composite Tree
SNCT <- NetworkCausalTrees(effweights = c(0.5,0,0,0.5), method = "composite", # singular
output = "estimation", # detection, estimation
A = adiac_matrix,
p = rep(probT,n), Ne = NeighNum,
W = w, Y = y, X = X, M = M, G = g,
mdisc = 8, mest = 7,
minpopfrac = 1,
depth = 2,
fracpredictors = 1,
minsize= 15,
n_trees = 1)
SNCT
cor(x2, x5)
i
# Tau1000
tau1000 <- rep(0, n)
tau1000[x1==0 & x2==0] <- i
tau1000[x1==0 & x2==1] <- -i
# Tau 0100
eta0100 <- rep(0, n)
eta0100[x1==1 & x3==0] <- i
eta0100[x1==1 & x3==1] <- -i
## Generate Treatment Effects
y00 <- rnorm(n)
y11 <- rnorm(n)
y10 <- y00 + tau1000
y01 <- y00 + eta0100
## Generate Outcome
y <- y00*(1-w)*(1-g) + y10*w*(1-g) + y01*(1-w)*g + y11*w*g
## Run the  whole function
## Composite Tree
SNCT <- NetworkCausalTrees(effweights = c(0.5,0,0,0.5), method = "composite", # singular
output = "estimation", # detection, estimation
A = adiac_matrix,
p = rep(probT,n), Ne = NeighNum,
W = w, Y = y, X = X, M = M, G = g,
mdisc = 8, mest = 7,
minpopfrac = 1,
depth = 2,
fracpredictors = 1,
minsize= 15,
n_trees = 1)
SNCT
# Tau1000
tau1000 <- rep(0, n)
tau1000[x1==0 & x2==0] <- 2*i
tau1000[x1==0 & x2==1] <- i
# Tau 0100
eta0100 <- rep(0, n)
eta0100[x1==1 & x3==0] <- -2*i
eta0100[x1==1 & x3==1] <- -i
## Generate Treatment Effects
y00 <- rnorm(n)
y11 <- rnorm(n)
y10 <- y00 + tau1000
y01 <- y00 + eta0100
## Generate Outcome
y <- y00*(1-w)*(1-g) + y10*w*(1-g) + y01*(1-w)*g + y11*w*g
## Run the  whole function
## Composite Tree
SNCT <- NetworkCausalTrees(effweights = c(0.5,0,0,0.5), method = "composite", # singular
output = "estimation", # detection, estimation
A = adiac_matrix,
p = rep(probT,n), Ne = NeighNum,
W = w, Y = y, X = X, M = M, G = g,
mdisc = 8, mest = 7,
minpopfrac = 1,
depth = 2,
fracpredictors = 1,
minsize= 15,
n_trees = 1)
SNCT
i
i = 5
# Tau1000
tau1000 <- rep(0, n)
tau1000[x1==0 & x2==0] <- 2*i
tau1000[x1==0 & x2==1] <- i
# Tau 0100
eta0100 <- rep(0, n)
eta0100[x1==1 & x3==0] <- -2*i
eta0100[x1==1 & x3==1] <- -i
## Generate Treatment Effects
y00 <- rnorm(n)
y11 <- rnorm(n)
y10 <- y00 + tau1000
y01 <- y00 + eta0100
## Generate Outcome
y <- y00*(1-w)*(1-g) + y10*w*(1-g) + y01*(1-w)*g + y11*w*g
## Run the  whole function
## Composite Tree
SNCT <- NetworkCausalTrees(effweights = c(0.5,0,0,0.5), method = "composite", # singular
output = "estimation", # detection, estimation
A = adiac_matrix,
p = rep(probT,n), Ne = NeighNum,
W = w, Y = y, X = X, M = M, G = g,
mdisc = 8, mest = 7,
minpopfrac = 1,
depth = 2,
fracpredictors = 1,
minsize= 15,
n_trees = 1)
SNCT
## Extract the Correct Rules
correct.composite.spil <- length(which(rule.spil=="data_tree$X.1>=1 & data_tree$X.3>=1" |
rule.spil=="data_tree$X.3>=1 & data_tree$X.1>=1" |
rule.spil=="data_tree$X.1<1 & data_tree$X.2<1" |
rule.spil=="data_tree$X.2<1 & data_tree$X.1<1"))
correct.rules.composite.spil[j, which(seq==i)] <- correct.composite.spil
correct.composite.spil
correct.singlemain.spil <- length(which(rule.main=="data_tree$X.1>=1 & data_tree$X.3>=1" |
rule.main=="data_tree$X.3>=1 & data_tree$X.1>=1" |
rule.main=="data_tree$X.1<1 & data_tree$X.2<1" |
rule.main=="data_tree$X.2<1 & data_tree$X.1<1"))
correct.singlemain.spil
correct.spil <- length(which(rule.spil=="data_tree$X.1>=1 & data_tree$X.3>=1" |
rule.spil=="data_tree$X.3>=1 & data_tree$X.1>=1" |
rule.spil=="data_tree$X.1<1 & data_tree$X.2<1" |
rule.spil=="data_tree$X.2<1 & data_tree$X.1<1"))
correct.spil
rule.main
correct.composite.spil <- length(which(rule.spil=="data_tree$X.1>=1 & data_tree$X.3>=1" |
rule.spil=="data_tree$X.3>=1 & data_tree$X.1>=1" |
rule.spil=="data_tree$X.1<1 & data_tree$X.2<1" |
rule.spil=="data_tree$X.2<1 & data_tree$X.1<1"))
correct.rules.composite.spil[j, which(seq==i)] <- correct.composite.spil
correct.singlemain.spil <- length(which(rule.main=="data_tree$X.1>=1 & data_tree$X.3>=1" |
rule.main=="data_tree$X.3>=1 & data_tree$X.1>=1" |
rule.main=="data_tree$X.1<1 & data_tree$X.2<1" |
rule.main=="data_tree$X.2<1 & data_tree$X.1<1"))
correct.rules.singlemain.spil[j, which(seq==i)] <- correct.singlemain.spil
correct.spil <- length(which(rule.spil=="data_tree$X.1>=1 & data_tree$X.3>=1" |
rule.spil=="data_tree$X.3>=1 & data_tree$X.1>=1" |
rule.spil=="data_tree$X.1<1 & data_tree$X.2<1" |
rule.spil=="data_tree$X.2<1 & data_tree$X.1<1"))
length(which(rule.main=="data_tree$X.1<1 & data_tree$X.2>=1" |
rule.main=="data_tree$X.2>=1 & data_tree$X.1<1" |
rule.main=="data_tree$X.1<1 & data_tree$X.2<1" |
rule.main=="data_tree$X.2<1 & data_tree$X.1<1"))
length(which(rule.sel=="data_tree$X.1<1 & data_tree$X.2>=1" |
rule.sel=="data_tree$X.2>=1 & data_tree$X.1<1" |
rule.sel=="data_tree$X.1<1 & data_tree$X.2<1" |
rule.sel=="data_tree$X.2<1 & data_tree$X.1<1"))
length(which(rule.main=="data_tree$X.1<1 & data_tree$X.2>=1" |
rule.main=="data_tree$X.2>=1 & data_tree$X.1<1" |
rule.main=="data_tree$X.1<1 & data_tree$X.2<1" |
rule.main=="data_tree$X.2<1 & data_tree$X.1<1"))
length(which(rule.spil=="data_tree$X.1<1 & data_tree$X.2>=1" |
rule.spil=="data_tree$X.2>=1 & data_tree$X.1<1" |
rule.spil=="data_tree$X.1<1 & data_tree$X.2<1" |
rule.spil=="data_tree$X.2<1 & data_tree$X.1<1"))
length(which(rule.sel=="data_tree$X.1>=1 & data_tree$X.3>=1" |
rule.sel=="data_tree$X.3>=1 & data_tree$X.1>=1" |
rule.sel=="data_tree$X.1<1 & data_tree$X.2<1" |
rule.sel=="data_tree$X.2<1 & data_tree$X.1<1"))
length(which(rule.main=="data_tree$X.1>=1 & data_tree$X.3>=1" |
rule.main=="data_tree$X.3>=1 & data_tree$X.1>=1" |
rule.main=="data_tree$X.1<1 & data_tree$X.2<1" |
rule.main=="data_tree$X.2<1 & data_tree$X.1<1"))
length(which(rule.spil=="data_tree$X.1>=1 & data_tree$X.3>=1" |
rule.spil=="data_tree$X.3>=1 & data_tree$X.1>=1" |
rule.spil=="data_tree$X.1<1 & data_tree$X.2<1" |
rule.spil=="data_tree$X.2<1 & data_tree$X.1<1"))
SNCT_main <- NetworkCausalTrees(effweights = c(1,0,0,0), method = "singular",
output = "estimation", # detection, estimation
A = adiac_matrix,
p = rep(probT,n), Ne = NeighNum,
W = w, Y = y, X = X, M = M, G = g,
mdisc = 8, mest = 7,
minpopfrac = 1,
depth = 2,
fracpredictors = 1,
minsize= 15,
n_trees = 1)
# http://www.r-bloggers.com/merry-christmas-5/?utm_source=feedburner&utm_medium=feed&utm_campaign=Feed%3A+RBloggers+%28R+bloggers%29
# Each row is a 2x2 linear transformation
# Christmas tree
L <-  matrix(
c(0.03,  0,     0  ,  0.1,
0.85,  0.00,  0.00, 0.85,
0.8,   0.00,  0.00, 0.8,
0.2,  -0.08,  0.15, 0.22,
-0.2,   0.08,  0.15, 0.22,
0.25, -0.1,   0.12, 0.25,
-0.2,   0.1,   0.12, 0.2),
nrow=4)
# ... and each row is a translation vector
B <- matrix(
c(0, 0,
0, 1.5,
0, 1.5,
0, 0.85,
0, 0.85,
0, 0.3,
0, 0.4),
nrow=2)
prob = c(0.02, 0.6,.08, 0.07, 0.07, 0.07, 0.07)
# Iterate the discrete stochastic map
N = 1e5 #5  #   number of iterations
x = matrix(NA,nrow=2,ncol=N)
x[,1] = c(0,2)   # initial point
k <- sample(1:7,N,prob,replace=TRUE) # values 1-7
for (i in 2:N)
x[,i] = crossprod(matrix(L[,k[i]],nrow=2),x[,i-1]) + B[,k[i]] # iterate
# Plot the iteration history
par(bg='darkblue',mar=rep(0,4))
plot(x=x[1,],y=x[2,],
col=grep('green',colors(),value=TRUE),
axes=FALSE,
cex=.1,
xlab='',
ylab='' )#,pch='.')
bals <- sample(N,20)
points(x=x[1,bals],y=x[2,bals]-.1,
col=c('red','blue','yellow','orange'),
cex=2,
pch=19
)
text(x=-.7,y=8,
labels='Merry',
adj=c(.5,.5),
srt=45,
vfont=c('script','plain'),
cex=3,
col='gold'
)
text(x=0.7,y=8,
labels='Christmas',
adj=c(.5,.5),
srt=-45,
vfont=c('script','plain'),
cex=3,
col='gold'
)
text(x=-0.6,y=0,
cex=0.8,
labels="To Chengdu R Users Group members",
col="white"
)
# http://www.r-bloggers.com/merry-christmas-5/?utm_source=feedburner&utm_medium=feed&utm_campaign=Feed%3A+RBloggers+%28R+bloggers%29
# Each row is a 2x2 linear transformation
# Christmas tree
L <-  matrix(
c(0.03,  0,     0  ,  0.1,
0.85,  0.00,  0.00, 0.85,
0.8,   0.00,  0.00, 0.8,
0.2,  -0.08,  0.15, 0.22,
-0.2,   0.08,  0.15, 0.22,
0.25, -0.1,   0.12, 0.25,
-0.2,   0.1,   0.12, 0.2),
nrow=4)
# ... and each row is a translation vector
B <- matrix(
c(0, 0,
0, 1.5,
0, 1.5,
0, 0.85,
0, 0.85,
0, 0.3,
0, 0.4),
nrow=2)
prob = c(0.02, 0.6,.08, 0.07, 0.07, 0.07, 0.07)
# Iterate the discrete stochastic map
N = 1e5 #5  #   number of iterations
x = matrix(NA,nrow=2,ncol=N)
x[,1] = c(0,2)   # initial point
k <- sample(1:7,N,prob,replace=TRUE) # values 1-7
for (i in 2:N)
x[,i] = crossprod(matrix(L[,k[i]],nrow=2),x[,i-1]) + B[,k[i]] # iterate
# Plot the iteration history
par(bg='darkblue',mar=rep(0,4))
plot(x=x[1,],y=x[2,],
col=grep('green',colors(),value=TRUE),
axes=FALSE,
cex=.1,
xlab='',
ylab='' )#,pch='.')
bals <- sample(N,20)
points(x=x[1,bals],y=x[2,bals]-.1,
col=c('red','blue','yellow','orange'),
cex=2,
pch=19
)
text(x=-.7,y=8,
labels='Dankje',
adj=c(.5,.5),
srt=45,
vfont=c('script','plain'),
cex=3,
col='gold'
)
text(x=0.7,y=8,
labels='Sinterklaas',
adj=c(.5,.5),
srt=-45,
vfont=c('script','plain'),
cex=3,
col='gold'
)
text(x=-0.6,y=0,
cex=0.8,
labels="To Chengdu R Users Group members",
col="white
=
0
?
'098789)
=?
'^'
*
)
)
)
)
)
)
}
}
}
